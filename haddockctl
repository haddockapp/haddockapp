#!/bin/bash

#############################################
# Haddock Control Script (haddockctl)
# Manage your Haddock installation
#############################################

set -e

# Script directory and paths
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Adjust paths for production environment
if [ "$SCRIPT_DIR" != "/opt/haddock" ] && [ -d "/opt/haddock" ]; then
    SCRIPT_DIR="/opt/haddock"
fi

API_DIR="$SCRIPT_DIR/api"

# Default configuration
LOG_FILE="/var/log/haddockctl.log"
GITHUB_REPO="haddockapp/haddockapp"

# Colors
GREEN='\033[1;32m'
RED='\033[1;31m'
BLUE='\033[1;34m'
YELLOW='\033[1;33m'
PURPLE='\033[1;35m'
NC='\033[0m'
BOLD='\033[1m'

# Logging function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >> "$LOG_FILE" 2>&1
}

# Output functions
print_header() {
    clear
    echo -e "${BLUE}${BOLD}"
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘        ðŸ³ Haddock Control Panel ðŸ³           â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${NC}"
}

print_success() {
    echo -e "${GREEN}âœ“${NC} $1"
    log "SUCCESS: $1"
}

print_error() {
    echo -e "${RED}âœ—${NC} $1"
    log "ERROR: $1"
}

print_info() {
    echo -e "${BLUE}â„¹${NC} $1"
    log "INFO: $1"
}

print_warning() {
    echo -e "${YELLOW}âš ${NC} $1"
    log "WARNING: $1"
}

# Check if script is run as root
check_root() {
    if [ "$EUID" -ne 0 ]; then
        print_error "This script must be run as root (use sudo)"
        exit 1
    fi
}

# Check if database is running
check_database() {
    if systemctl is-active --quiet postgresql; then
        return 0
    else
        print_warning "PostgreSQL service is not running"
        return 1
    fi
}

# Get database connection details
get_db_credentials() {
    # Read from .env file or use defaults
    if [ -f "$API_DIR/.env" ]; then
        DATABASE_URL=$(grep "^DATABASE_URL=" "$API_DIR/.env" | cut -d'=' -f2-)
        # Parse DATABASE_URL: postgresql://user:pass@host:port/db
        POSTGRES_USER=$(echo "$DATABASE_URL" | sed -n 's/.*:\/\/\([^:]*\):.*/\1/p')
        POSTGRES_PASSWORD=$(echo "$DATABASE_URL" | sed -n 's/.*:\/\/[^:]*:\([^@]*\)@.*/\1/p')
        POSTGRES_DB=$(echo "$DATABASE_URL" | sed -n 's/.*\/\([^?]*\).*/\1/p')
    fi
    # Defaults for production
    POSTGRES_USER=${POSTGRES_USER:-haddock}
    POSTGRES_PASSWORD=${POSTGRES_PASSWORD:-haddock}
    POSTGRES_DB=${POSTGRES_DB:-haddock}
    POSTGRES_HOST="localhost"
}

#############################################
# Password Reset Function
#############################################
reset_admin_password() {
    print_header
    echo -e "${BOLD}Reset Admin Password${NC}\n"
    
    # Check prerequisites
    if ! check_database; then
        print_info "Starting PostgreSQL service..."
        systemctl start postgresql
        sleep 3
    fi
    
    get_db_credentials
    
    # Get admin user
    print_info "Finding admin user..."
    ADMIN_EMAIL=$(sudo -u postgres psql -d "$POSTGRES_DB" -t -c "SELECT email FROM \"User\" WHERE role='admin' LIMIT 1;" 2>/dev/null | tr -d ' \n')
    
    if [ -z "$ADMIN_EMAIL" ]; then
        print_error "No admin user found in database"
        echo ""
        read -p "Press Enter to return to menu..."
        return 1
    fi
    
    print_success "Admin user found: $ADMIN_EMAIL"
    echo ""
    
    # Get new password
    while true; do
        read -sp "Enter new admin password: " NEW_PASSWORD
        echo ""
        
        if [ ${#NEW_PASSWORD} -lt 8 ]; then
            print_error "Password must be at least 8 characters long"
            continue
        fi
        
        read -sp "Confirm new password: " CONFIRM_PASSWORD
        echo ""
        
        if [ "$NEW_PASSWORD" != "$CONFIRM_PASSWORD" ]; then
            print_error "Passwords do not match"
            continue
        fi
        
        break
    done
    
    # Hash password using Node.js and bcrypt
    print_info "Hashing password..."
    
    # Create temporary Node.js script to hash password
    TEMP_SCRIPT=$(mktemp)
    cat > "$TEMP_SCRIPT" << 'EOF'
const bcrypt = require('bcrypt');
const password = process.argv[2];

async function hashPassword() {
    const salt = await bcrypt.genSalt(10);
    const hash = await bcrypt.hash(password, salt);
    console.log(hash);
}

hashPassword();
EOF
    
    # Hash the password (using API directory for node_modules)
    cd "$API_DIR"
    PASSWORD_HASH=$(node -e "$(cat $TEMP_SCRIPT)" "$NEW_PASSWORD" 2>/dev/null)
    rm -f "$TEMP_SCRIPT"
    
    if [ -z "$PASSWORD_HASH" ]; then
        print_error "Failed to hash password"
        echo ""
        read -p "Press Enter to return to menu..."
        return 1
    fi
    
    # Update password in database
    print_info "Updating password in database..."
    sudo -u postgres psql -d "$POSTGRES_DB" -v email="$ADMIN_EMAIL" -v hash="$PASSWORD_HASH" -c \
        "UPDATE \"User\" SET password=:'hash' WHERE email=:'email';" >/dev/null 2>&1
    
    if [ $? -eq 0 ]; then
        echo ""
        print_success "Admin password has been successfully reset!"
        print_info "You can now login with email: $ADMIN_EMAIL"
    else
        print_error "Failed to update password in database"
    fi
    
    echo ""
    read -p "Press Enter to return to menu..."
}

#############################################
# Update Functions
#############################################

# Get current version
get_current_version() {
    if [ -f "$API_DIR/package.json" ]; then
        CURRENT_VERSION=$(grep -m 1 '"version"' "$API_DIR/package.json" | cut -d'"' -f4)
    else
        CURRENT_VERSION="unknown"
    fi
    echo "$CURRENT_VERSION"
}

# Get latest version from GitHub
get_latest_version() {
    # Try to get latest tag from GitHub API
    local LATEST_VERSION=$(curl -s "https://api.github.com/repos/$GITHUB_REPO/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
    
    if [ -z "$LATEST_VERSION" ]; then
        # Fallback to tags if no releases
        LATEST_VERSION=$(curl -s "https://api.github.com/repos/$GITHUB_REPO/tags" | grep '"name":' | head -1 | sed -E 's/.*"([^"]+)".*/\1/')
    fi
    
    echo "$LATEST_VERSION"
}

# Compare versions
version_gt() {
    test "$(printf '%s\n' "$@" | sort -V | head -n 1)" != "$1"
}

# Check for updates
check_updates() {
    print_header
    echo -e "${BOLD}Check for Updates${NC}\n"
    
    CURRENT_VERSION=$(get_current_version)
    print_info "Current version: $CURRENT_VERSION"
    
    print_info "Checking for updates from GitHub..."
    LATEST_VERSION=$(get_latest_version)
    
    if [ -z "$LATEST_VERSION" ] || [ "$LATEST_VERSION" = "null" ]; then
        print_warning "Could not fetch latest version from GitHub"
        print_info "Repository: https://github.com/$GITHUB_REPO"
        echo ""
        read -p "Press Enter to return to menu..."
        return 1
    fi
    
    print_info "Latest version: $LATEST_VERSION"
    echo ""
    
    # Remove 'v' prefix if present for comparison
    CURRENT_CLEAN="${CURRENT_VERSION#v}"
    LATEST_CLEAN="${LATEST_VERSION#v}"
    
    if [ "$CURRENT_CLEAN" = "$LATEST_CLEAN" ]; then
        print_success "You are running the latest version!"
    elif version_gt "$LATEST_CLEAN" "$CURRENT_CLEAN"; then
        print_warning "A new version is available: $LATEST_VERSION"
        echo ""
        read -p "Do you want to update now? [y/N] " -n 1 -r
        echo ""
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            perform_update "$LATEST_VERSION"
            return
        fi
    else
        print_info "You are running a development version ($CURRENT_VERSION)"
    fi
    
    echo ""
    read -p "Press Enter to return to menu..."
}

# Perform update
perform_update() {
    local TARGET_VERSION=$1
    
    print_header
    echo -e "${BOLD}Updating Haddock to $TARGET_VERSION${NC}\n"
    
    # Check if git is available
    if ! command -v git &> /dev/null; then
        print_error "Git is not installed. Cannot perform update."
        echo ""
        read -p "Press Enter to return to menu..."
        return 1
    fi
    
    # Create backup
    print_info "Creating backup..."
    BACKUP_DIR="/var/backups/haddock/update-$(date +%Y%m%d-%H%M%S)"
    mkdir -p "$BACKUP_DIR"
    
    # Backup database
    if check_database; then
        get_db_credentials
        print_info "Backing up database..."
        if sudo -u postgres pg_dump "$POSTGRES_DB" > "$BACKUP_DIR/database.sql"; then
            print_success "Database backed up to $BACKUP_DIR/database.sql"
        else
            print_error "Database backup failed! Aborting update."
            echo ""
            read -p "Press Enter to return to menu..."
            return 1
        fi
    fi
    
    # Backup configs
    cp "$API_DIR/.env" "$BACKUP_DIR/" 2>/dev/null || true
    cp -r /etc/caddy/*.caddy "$BACKUP_DIR/" 2>/dev/null || true
    
    print_success "Backup created at $BACKUP_DIR"
    echo ""
    
    # Stop services
    print_info "Stopping services..."
    pm2 stop haddock-api 2>/dev/null || true
    systemctl stop caddy 2>/dev/null || true
    
    # Update code
    print_info "Updating code from GitHub..."
    cd "$SCRIPT_DIR"
    
    # Check if this is a git repository
    if [ -d ".git" ]; then
        # Check if there are local changes to stash
        STASH_CREATED=false
        if ! git diff-index --quiet HEAD --; then
            print_info "Stashing local changes..."
            git stash save "Auto-stash before update to $TARGET_VERSION"
            STASH_CREATED=true
            print_success "Local changes stashed (will be restored after update)"
        fi
        
        # Fetch updates
        git fetch --all --tags
        
        # Checkout the target version (must be a tag)
        if git rev-parse --verify --quiet "refs/tags/$TARGET_VERSION" >/dev/null; then
            git checkout "tags/$TARGET_VERSION"
            print_success "Code updated to tag $TARGET_VERSION"
        else
            print_error "Tag $TARGET_VERSION does not exist. Aborting update."
            
            # Restore stashed changes if we stashed them
            if [ "$STASH_CREATED" = true ]; then
                print_info "Restoring stashed changes..."
                cd "$SCRIPT_DIR"
                if git stash pop; then
                    print_success "Stashed changes restored"
                else
                    print_warning "Could not restore stashed changes automatically. Run 'git stash pop' manually."
                fi
            fi
            
            echo ""
            read -p "Press Enter to return to menu..."
            return 1
        fi
    else
        print_warning "Not a git repository. Downloading release..."
        
        # Download and extract release
        TEMP_DIR=$(mktemp -d)
        curl -sL "https://github.com/$GITHUB_REPO/archive/refs/tags/$TARGET_VERSION.tar.gz" -o "$TEMP_DIR/release.tar.gz"
        
        if [ $? -eq 0 ]; then
            tar --strip-components=1 -xzf "$TEMP_DIR/release.tar.gz" -C "$TEMP_DIR"
            
            # Copy new files (preserve database and custom configs)
            print_info "Copying new files..."
            
            # Copy all files except configs
            find "$TEMP_DIR" -type f ! -name '*.yml' ! -name '.env' -exec cp --parents {} "$SCRIPT_DIR/" \; 2>/dev/null
            
            rm -rf "$TEMP_DIR"
            print_success "Release downloaded and extracted"
        else
            print_error "Failed to download release"
            rm -rf "$TEMP_DIR"
            echo ""
            read -p "Press Enter to return to menu..."
            return 1
        fi
    fi
    
    echo ""
    print_info "Installing dependencies..."
    
    # Update API dependencies
    if [ -f "$API_DIR/package.json" ]; then
        cd "$API_DIR"
        print_info "Installing API dependencies..."
        yarn install --frozen-lockfile 2>&1 | tee -a "$LOG_FILE"
    fi
    
    # Update Frontend dependencies
    if [ -f "$SCRIPT_DIR/frontend/package.json" ]; then
        cd "$SCRIPT_DIR/frontend"
        print_info "Installing Frontend dependencies..."
        yarn install --frozen-lockfile 2>&1 | tee -a "$LOG_FILE"
    fi
    
    # Build API
    print_info "Building API..."
    cd "$API_DIR"
    yarn build 2>&1 | tee -a "$LOG_FILE"
    
    # Build Frontend (if needed)
    if [ -d "$SCRIPT_DIR/frontend" ]; then
        print_info "Building Frontend..."
        cd "$SCRIPT_DIR/frontend"
        yarn build 2>&1 | tee -a "$LOG_FILE"
    fi
    
    # Run database migrations
    print_info "Running database migrations..."
    cd "$API_DIR"
    npx prisma db push 2>&1 | tee -a "$LOG_FILE"
    
    # Start services
    print_info "Starting services..."
    systemctl start caddy
    cd "$API_DIR"
    pm2 restart haddock-api || pm2 start yarn --name haddock-api -- start:prod
    pm2 save
    
    echo ""
    print_success "Update completed successfully!"
    print_info "Haddock is now running version $TARGET_VERSION"
    print_info "Backup available at: $BACKUP_DIR"
    
    # Restore stashed changes if we stashed them
    if [ "$STASH_CREATED" = true ]; then
        echo ""
        print_info "Restoring previously stashed changes..."
        cd "$SCRIPT_DIR"
        if git stash pop; then
            print_success "Stashed changes restored successfully"
        else
            print_warning "Could not restore stashed changes automatically."
            print_warning "There may be conflicts with the updated code."
            print_info "To restore manually, run: cd $SCRIPT_DIR && git stash pop"
        fi
    fi
    
    echo ""
    read -p "Press Enter to return to menu..."
}

#############################################
# System Status
#############################################
show_status() {
    print_header
    echo -e "${BOLD}System Status${NC}\n"
    
    CURRENT_VERSION=$(get_current_version)
    echo -e "${BOLD}Version:${NC} $CURRENT_VERSION"
    echo ""
    
    # Check services
    echo -e "${BOLD}Services:${NC}"
    
    # PostgreSQL
    if systemctl is-active --quiet postgresql; then
        print_success "PostgreSQL: Running"
    else
        print_error "PostgreSQL: Stopped"
    fi
    
    # Redis
    if systemctl is-active --quiet redis-server || systemctl is-active --quiet redis; then
        print_success "Redis: Running"
    else
        print_error "Redis: Stopped"
    fi
    
    # Caddy
    if systemctl is-active --quiet caddy; then
        print_success "Caddy: Running"
    else
        print_error "Caddy: Stopped"
    fi
    
    # PM2 API
    if pm2 list 2>/dev/null | grep -q "haddock-api.*online"; then
        print_success "API (PM2): Running"
    else
        print_error "API (PM2): Stopped"
    fi
    
    # Check if API is responding
    echo ""
    if curl -s http://localhost:3000/health >/dev/null 2>&1; then
        print_success "API: Responding on port 3000"
    else
        print_warning "API: Not responding on port 3000"
    fi
    
    echo ""
    echo -e "${BOLD}Paths:${NC}"
    echo "  Installation: $SCRIPT_DIR"
    echo "  API: $API_DIR"
    echo "  Logs: $LOG_FILE"
    echo "  PM2 Logs: $(pm2 info haddock-api 2>/dev/null | grep "log path" | awk '{print $4}' || echo "N/A")"
    
    echo ""
    read -p "Press Enter to return to menu..."
}

#############################################
# Main Menu
#############################################
show_menu() {
    print_header
    echo "Please select an option:"
    echo ""
    echo "  1) Reset Admin Password"
    echo "  2) Check for Updates"
    echo "  3) Show System Status"
    echo "  4) View Logs"
    echo "  5) Restart Services"
    echo "  6) Exit"
    echo ""
    read -p "Enter your choice [1-6]: " choice
    
    case $choice in
        1)
            reset_admin_password
            ;;
        2)
            check_updates
            ;;
        3)
            show_status
            ;;
        4)
            view_logs
            ;;
        5)
            restart_services
            ;;
        6)
            echo ""
            print_info "Goodbye!"
            exit 0
            ;;
        *)
            print_error "Invalid option"
            sleep 2
            ;;
    esac
}

# View logs
view_logs() {
    print_header
    echo -e "${BOLD}Recent Logs${NC}\n"
    
    if [ -f "$LOG_FILE" ]; then
        tail -50 "$LOG_FILE"
    else
        print_warning "No log file found"
    fi
    
    echo ""
    read -p "Press Enter to return to menu..."
}

# Restart services
restart_services() {
    print_header
    echo -e "${BOLD}Restart Services${NC}\n"
    
    print_info "Restarting Haddock services..."
    
    print_info "Restarting PostgreSQL..."
    systemctl restart postgresql
    
    print_info "Restarting Redis..."
    systemctl restart redis-server || systemctl restart redis
    
    print_info "Restarting Caddy..."
    systemctl restart caddy
    
    print_info "Restarting API (PM2)..."
    cd "$API_DIR"
    pm2 restart haddock-api
    
    print_success "All services restarted successfully"
    
    echo ""
    read -p "Press Enter to return to menu..."
}

#############################################
# Help and Version
#############################################
show_help() {
    echo "Haddockctl - Haddock Management CLI"
    echo ""
    echo "Usage: haddockctl [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  -h, --help       Show this help message"
    echo "  -v, --version    Show version information"
    echo ""
    echo "When run without options, launches the interactive menu."
    echo ""
    echo "For more information, see: README.md"
}

show_version() {
    CURRENT_VERSION=$(get_current_version)
    echo "Haddockctl version $CURRENT_VERSION"
    echo "Part of Haddock - Your All-in-One Platform Engineer"
}

#############################################
# Main
#############################################
main() {
    # Handle command line arguments
    case "${1:-}" in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--version)
            show_version
            exit 0
            ;;
        "")
            # No arguments, continue to interactive menu
            ;;
        *)
            echo "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
    
    # Check root
    check_root
    
    # Create log file if it doesn't exist
    touch "$LOG_FILE" 2>/dev/null || true
    
    log "=== Haddockctl started ==="
    
    # Main loop
    while true; do
        show_menu
    done
}

# Run main function
main "$@"

